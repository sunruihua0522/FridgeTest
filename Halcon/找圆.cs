//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using System.Windows.Forms;
using HalconDotNet;

public partial class HDevelopExport
{
  public HTuple hv_ExpDefaultWinHandle;

  public void HDevelopStop()
  {
    MessageBox.Show("Press button to continue", "Program stop");
  }

  // Procedures 
  // External procedures 
  public void draw_spoke (HObject ho_Image, out HObject ho_Regions, HTuple hv_WindowHandle, 
      HTuple hv_Elements, HTuple hv_DetectHeight, HTuple hv_DetectWidth, out HTuple hv_ROIRows, 
      out HTuple hv_ROICols, out HTuple hv_Direct)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ContOut1, ho_Contour, ho_ContCircle;
    HObject ho_Cross, ho_Rectangle1=null, ho_Arrow1=null;

    // Local control variables 

    HTuple hv_Rows = null, hv_Cols = null, hv_Weights = null;
    HTuple hv_Length1 = null, hv_RowC = null, hv_ColumnC = null;
    HTuple hv_Radius = null, hv_StartPhi = null, hv_EndPhi = null;
    HTuple hv_PointOrder = null, hv_RowXLD = null, hv_ColXLD = null;
    HTuple hv_Row1 = null, hv_Column1 = null, hv_Row2 = null;
    HTuple hv_Column2 = null, hv_DistanceStart = null, hv_DistanceEnd = null;
    HTuple hv_Length2 = null, hv_i = null, hv_j = new HTuple();
    HTuple hv_RowE = new HTuple(), hv_ColE = new HTuple();
    HTuple hv_ATan = new HTuple(), hv_RowL2 = new HTuple();
    HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
    HTuple hv_ColL1 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_ContOut1);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    HOperatorSet.GenEmptyObj(out ho_Rectangle1);
    HOperatorSet.GenEmptyObj(out ho_Arrow1);
    hv_ROIRows = new HTuple();
    hv_ROICols = new HTuple();
    hv_Direct = new HTuple();
    //??
    disp_message(hv_ExpDefaultWinHandle, new HTuple("1??4??????????,??????"), "window", 
        12, 12, "red", "false");
    //?????????,????
    ho_Regions.Dispose();
    HOperatorSet.GenEmptyObj(out ho_Regions);
    //???????????
    ho_ContOut1.Dispose();
    HOperatorSet.DrawNurbs(out ho_ContOut1, hv_ExpDefaultWinHandle, "true", "true", 
        "true", "true", 3, out hv_Rows, out hv_Cols, out hv_Weights);
    //???4??
    HOperatorSet.TupleLength(hv_Weights, out hv_Length1);
    if ((int)(new HTuple(hv_Length1.TupleLess(4))) != 0)
    {
      disp_message(hv_ExpDefaultWinHandle, "??:????,???", "window", 32, 12, "red", 
          "false");
      hv_ROIRows = new HTuple();
      hv_ROICols = new HTuple();
      ho_ContOut1.Dispose();
      ho_Contour.Dispose();
      ho_ContCircle.Dispose();
      ho_Cross.Dispose();
      ho_Rectangle1.Dispose();
      ho_Arrow1.Dispose();

      return;
    }
    //???
    hv_ROIRows = hv_Rows.Clone();
    hv_ROICols = hv_Cols.Clone();
    //??xld
    ho_Contour.Dispose();
    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
    //?????(??????,???????)???
    HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, out hv_RowC, 
        out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
    //????????xld,????????
    ho_ContCircle.Dispose();
    HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius, 
        hv_StartPhi, hv_EndPhi, hv_PointOrder, 3);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ConcatObj(ho_Regions, ho_ContCircle, out ExpTmpOutVar_0);
    ho_Regions.Dispose();
    ho_Regions = ExpTmpOutVar_0;
    }

    //??????xld?????
    HOperatorSet.GetContourXld(ho_ContCircle, out hv_RowXLD, out hv_ColXLD);
    //???????
    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
    HOperatorSet.DispObj(ho_ContCircle, hv_ExpDefaultWinHandle);
    //???????
    ho_Cross.Dispose();
    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_RowC, hv_ColumnC, 60, 0.785398);
    HOperatorSet.DispObj(ho_Cross, hv_ExpDefaultWinHandle);
    //??
    disp_message(hv_ExpDefaultWinHandle, "2?????,???????????,??????", "window", 12, 
        12, "red", "false");
    //??,??????
    HOperatorSet.DrawLine(hv_ExpDefaultWinHandle, out hv_Row1, out hv_Column1, out hv_Row2, 
        out hv_Column2);
    //???????????????
    HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row1, hv_Column1, out hv_DistanceStart);
    //???????????????
    HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row2, hv_Column2, out hv_DistanceEnd);

    //?????xld??????
    HOperatorSet.TupleLength(hv_ColXLD, out hv_Length2);
    //?????????????
    if ((int)(new HTuple(hv_Elements.TupleLess(3))) != 0)
    {
      hv_ROIRows = new HTuple();
      hv_ROICols = new HTuple();
      disp_message(hv_ExpDefaultWinHandle, "?????????,?????!", "window", 52, 12, 
          "red", "false");
      ho_ContOut1.Dispose();
      ho_Contour.Dispose();
      ho_ContCircle.Dispose();
      ho_Cross.Dispose();
      ho_Rectangle1.Dispose();
      ho_Arrow1.Dispose();

      return;
    }
    //??xld???,?Length2??,?????,???(???Length2/(Elements-1))?Elements??,?????????
    //??xld??,?Length2??,?0°???,?????,???(???Length2/(Elements))?Elements??,?????????
    HTuple end_val53 = hv_Elements-1;
    HTuple step_val53 = 1;
    for (hv_i=0; hv_i.Continue(end_val53, step_val53); hv_i = hv_i.TupleAdd(step_val53))
    {

      if ((int)(new HTuple(((hv_RowXLD.TupleSelect(0))).TupleEqual(hv_RowXLD.TupleSelect(
          hv_Length2-1)))) != 0)
      {
        //xld??????????,??
        HOperatorSet.TupleInt(((1.0*hv_Length2)/hv_Elements)*hv_i, out hv_j);

      }
      else
      {
        //?????
        HOperatorSet.TupleInt(((1.0*hv_Length2)/(hv_Elements-1))*hv_i, out hv_j);
      }
      //????,???????????
      if ((int)(new HTuple(hv_j.TupleGreaterEqual(hv_Length2))) != 0)
      {
        hv_j = hv_Length2-1;
        //continue
      }
      //????????
      hv_RowE = hv_RowXLD.TupleSelect(hv_j);
      hv_ColE = hv_ColXLD.TupleSelect(hv_j);

      //??????????????????????????????????,???????????
      //???????????????????????????????????,???????????
      if ((int)(new HTuple(hv_DistanceStart.TupleGreater(hv_DistanceEnd))) != 0)
      {
        //????????????
        //?????????????
        HOperatorSet.TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, out hv_ATan);
        //????
        hv_ATan = ((new HTuple(180)).TupleRad())+hv_ATan;
        //????????:'inner'???????????;'outer'???????????
        hv_Direct = "inner";
      }
      else
      {
        //????????????
        //?????????????
        HOperatorSet.TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, out hv_ATan);
        //????????:'inner'???????????;'outer'???????????
        hv_Direct = "outer";
      }

      //????xld,????????
      ho_Rectangle1.Dispose();
      HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan, 
          hv_DetectHeight/2, hv_DetectWidth/2);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle1, out ExpTmpOutVar_0);
      ho_Regions.Dispose();
      ho_Regions = ExpTmpOutVar_0;
      }

      //???xld????????,????????
      if ((int)(new HTuple(hv_i.TupleEqual(0))) != 0)
      {
        hv_RowL2 = hv_RowE+((hv_DetectHeight/2)*(((-hv_ATan)).TupleSin()));
        hv_RowL1 = hv_RowE-((hv_DetectHeight/2)*(((-hv_ATan)).TupleSin()));
        hv_ColL2 = hv_ColE+((hv_DetectHeight/2)*(((-hv_ATan)).TupleCos()));
        hv_ColL1 = hv_ColE-((hv_DetectHeight/2)*(((-hv_ATan)).TupleCos()));
        ho_Arrow1.Dispose();
        gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2, 
            25, 25);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
        ho_Regions.Dispose();
        ho_Regions = ExpTmpOutVar_0;
        }
      }
    }

    ho_ContOut1.Dispose();
    ho_Contour.Dispose();
    ho_ContCircle.Dispose();
    ho_Cross.Dispose();
    ho_Rectangle1.Dispose();
    ho_Arrow1.Dispose();

    return;
  }

  public void spoke (HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements, 
      HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold, 
      HTuple hv_Transition, HTuple hv_Select, HTuple hv_ROIRows, HTuple hv_ROICols, 
      HTuple hv_Direct, out HTuple hv_ResultRow, out HTuple hv_ResultColumn, out HTuple hv_ArcType)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Contour, ho_ContCircle, ho_Rectangle1=null;
    HObject ho_Arrow1=null;

    // Local control variables 

    HTuple hv_Width = null, hv_Height = null, hv_RowC = null;
    HTuple hv_ColumnC = null, hv_Radius = null, hv_StartPhi = null;
    HTuple hv_EndPhi = null, hv_PointOrder = null, hv_RowXLD = null;
    HTuple hv_ColXLD = null, hv_Length2 = null, hv_i = null;
    HTuple hv_j = new HTuple(), hv_RowE = new HTuple(), hv_ColE = new HTuple();
    HTuple hv_ATan = new HTuple(), hv_RowL2 = new HTuple();
    HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
    HTuple hv_ColL1 = new HTuple(), hv_MsrHandle_Measure = new HTuple();
    HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
    HTuple hv_Amplitude = new HTuple(), hv_Distance = new HTuple();
    HTuple hv_tRow = new HTuple(), hv_tCol = new HTuple();
    HTuple hv_t = new HTuple(), hv_Number = new HTuple(), hv_k = new HTuple();
    HTuple   hv_Select_COPY_INP_TMP = hv_Select.Clone();
    HTuple   hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    HOperatorSet.GenEmptyObj(out ho_Rectangle1);
    HOperatorSet.GenEmptyObj(out ho_Arrow1);
    hv_ArcType = new HTuple();
    //??????
    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
    //?????????,????
    ho_Regions.Dispose();
    HOperatorSet.GenEmptyObj(out ho_Regions);
    //?????????
    hv_ResultRow = new HTuple();
    hv_ResultColumn = new HTuple();

    //??xld
    ho_Contour.Dispose();
    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
    //?????(??????,???????)???
    HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, out hv_RowC, 
        out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
    //????????xld,????????
    ho_ContCircle.Dispose();
    HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius, 
        hv_StartPhi, hv_EndPhi, hv_PointOrder, 3);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ConcatObj(ho_Regions, ho_ContCircle, out ExpTmpOutVar_0);
    ho_Regions.Dispose();
    ho_Regions = ExpTmpOutVar_0;
    }

    //??????xld?????
    HOperatorSet.GetContourXld(ho_ContCircle, out hv_RowXLD, out hv_ColXLD);

    //?????xld??????
    HOperatorSet.TupleLength(hv_ColXLD, out hv_Length2);
    if ((int)(new HTuple(hv_Elements.TupleLess(3))) != 0)
    {
      //    disp_message (WindowHandle, '?????????,?????!', 'window', 52, 12, 'red', 'false')
      ho_Contour.Dispose();
      ho_ContCircle.Dispose();
      ho_Rectangle1.Dispose();
      ho_Arrow1.Dispose();

      return;
    }
    //??xld???,?Length2??,?????,???(???Length2/(Elements-1))?Elements??,?????????
    //??xld??,?Length2??,?0°???,?????,???(???Length2/(Elements))?Elements??,?????????
    HTuple end_val27 = hv_Elements-1;
    HTuple step_val27 = 1;
    for (hv_i=0; hv_i.Continue(end_val27, step_val27); hv_i = hv_i.TupleAdd(step_val27))
    {

      if ((int)(new HTuple(((hv_RowXLD.TupleSelect(0))).TupleEqual(hv_RowXLD.TupleSelect(
          hv_Length2-1)))) != 0)
      {
        //xld??????????,??
        HOperatorSet.TupleInt(((1.0*hv_Length2)/hv_Elements)*hv_i, out hv_j);
        hv_ArcType = "circle";
      }
      else
      {
        //?????
        HOperatorSet.TupleInt(((1.0*hv_Length2)/(hv_Elements-1))*hv_i, out hv_j);
        hv_ArcType = "arc";
      }
      //????,???????????
      if ((int)(new HTuple(hv_j.TupleGreaterEqual(hv_Length2))) != 0)
      {
        hv_j = hv_Length2-1;
        //continue
      }
      //????????
      hv_RowE = hv_RowXLD.TupleSelect(hv_j);
      hv_ColE = hv_ColXLD.TupleSelect(hv_j);

      //??????,???,???????
      if ((int)((new HTuple((new HTuple((new HTuple(hv_RowE.TupleGreater(hv_Height-1))).TupleOr(
          new HTuple(hv_RowE.TupleLess(0))))).TupleOr(new HTuple(hv_ColE.TupleGreater(
          hv_Width-1))))).TupleOr(new HTuple(hv_ColE.TupleLess(0)))) != 0)
      {
        continue;
      }
      //????????:'inner'???????????;'outer'???????????
      if ((int)(new HTuple(hv_Direct.TupleEqual("inner"))) != 0)
      {
        //????????????
        //?????????????
        HOperatorSet.TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, out hv_ATan);
        //????
        hv_ATan = ((new HTuple(180)).TupleRad())+hv_ATan;
      }
      else
      {
        //????????????
        //?????????????
        HOperatorSet.TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, out hv_ATan);
      }


      //????xld,????????
      ho_Rectangle1.Dispose();
      HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan, 
          hv_DetectHeight/2, hv_DetectWidth/2);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle1, out ExpTmpOutVar_0);
      ho_Regions.Dispose();
      ho_Regions = ExpTmpOutVar_0;
      }
      //???xld????????,????????
      if ((int)(new HTuple(hv_i.TupleEqual(0))) != 0)
      {
        hv_RowL2 = hv_RowE+((hv_DetectHeight/2)*(((-hv_ATan)).TupleSin()));
        hv_RowL1 = hv_RowE-((hv_DetectHeight/2)*(((-hv_ATan)).TupleSin()));
        hv_ColL2 = hv_ColE+((hv_DetectHeight/2)*(((-hv_ATan)).TupleCos()));
        hv_ColL1 = hv_ColE-((hv_DetectHeight/2)*(((-hv_ATan)).TupleCos()));
        ho_Arrow1.Dispose();
        gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2, 
            25, 25);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
        ho_Regions.Dispose();
        ho_Regions = ExpTmpOutVar_0;
        }
      }


      //????????
      HOperatorSet.GenMeasureRectangle2(hv_RowE, hv_ColE, hv_ATan, hv_DetectHeight/2, 
          hv_DetectWidth/2, hv_Width, hv_Height, "nearest_neighbor", out hv_MsrHandle_Measure);

      //????
      if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
      {
        hv_Transition_COPY_INP_TMP = "negative";
      }
      else
      {
        if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
        {

          hv_Transition_COPY_INP_TMP = "positive";
        }
        else
        {
          hv_Transition_COPY_INP_TMP = "all";
        }
      }
      //???????????????????????????,?????'all'
      if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
      {
        hv_Select_COPY_INP_TMP = "first";
      }
      else
      {
        if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
        {

          hv_Select_COPY_INP_TMP = "last";
        }
        else
        {
          hv_Select_COPY_INP_TMP = "all";
        }
      }
      //????
      HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold, 
          hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge, 
          out hv_Amplitude, out hv_Distance);
      //????????
      HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);
      //???????
      //tRow,tCol???????????
      hv_tRow = 0;
      hv_tCol = 0;
      //t??????????
      hv_t = 0;
      HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
      //??????????1?
      if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
      {
        continue;
      }
      //??????,????????????
      HTuple end_val120 = hv_Number-1;
      HTuple step_val120 = 1;
      for (hv_k=0; hv_k.Continue(end_val120, step_val120); hv_k = hv_k.TupleAdd(step_val120))
      {
        if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_k))).TupleAbs())).TupleGreater(
            hv_t))) != 0)
        {

          hv_tRow = hv_RowEdge.TupleSelect(hv_k);
          hv_tCol = hv_ColEdge.TupleSelect(hv_k);
          hv_t = ((hv_Amplitude.TupleSelect(hv_k))).TupleAbs();
        }
      }
      //?????????????
      if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
      {

        hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
        hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
      }
    }


    ho_Contour.Dispose();
    ho_ContCircle.Dispose();
    ho_Rectangle1.Dispose();
    ho_Arrow1.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = null, hv_ImageWidth = null, hv_ImageHeight = null;
    HTuple hv_TempWidth = null, hv_TempHeight = null, hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = null;
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit.TupleSelect(0);
      hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit.TupleSelect(0);
      hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    //dev_open_window(...);
    HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GenParamName = null, hv_GenParamValue = null;
    HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
    HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
    HTuple   hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
    HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();

    // Initialize local and output iconic variables 
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Column: The column coordinate of the desired text position
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically...
    //   - if |Row| == |Column| == 1: for each new textline
    //   = else for each text position.
    //Box: If Box[0] is set to 'true', the text is written within an orange box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow
    //       otherwise -> use given string as color string for the shadow color
    //
    //It is possible to display multiple text strings in a single call.
    //In this case, some restrictions apply:
    //- Multiple text positions can be defined by specifying a tuple
    //  with multiple Row and/or Column coordinates, i.e.:
    //  - |Row| == n, |Column| == n
    //  - |Row| == n, |Column| == 1
    //  - |Row| == 1, |Column| == n
    //- If |Row| == |Column| == 1,
    //  each element of String is display in a new textline.
    //- If multiple positions or specified, the number of Strings
    //  must match the number of positions, i.e.:
    //  - Either |String| == n (each string is displayed at the
    //                          corresponding position),
    //  - or     |String| == 1 (The string is displayed n times).
    //
    //
    //Convert the parameters for disp_text.
    if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
    {

      return;
    }
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP = 12;
    }
    //
    //Convert the parameter Box to generic parameters.
    hv_GenParamName = new HTuple();
    hv_GenParamValue = new HTuple();
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
      {
        //Display no box
        hv_GenParamName = hv_GenParamName.TupleConcat("box");
        hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
      {
        //Set a color other than the default.
        hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
        hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
      }
    }
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
      {
        //Display no shadow.
        hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
        hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
      {
        //Set a shadow color other than the default.
        hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
        hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
      }
    }
    //Restore default CoordSystem behavior.
    if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
    {
      hv_CoordSystem_COPY_INP_TMP = "image";
    }
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      //disp_text does not accept an empty string for Color.
      hv_Color_COPY_INP_TMP = new HTuple();
    }
    //
    HOperatorSet.DispText(hv_ExpDefaultWinHandle, hv_String, hv_CoordSystem_COPY_INP_TMP, 
        hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName, 
        hv_GenParamValue);

    return;
  }

  // Chapter: XLD / Creation
  // Short Description: Creates an arrow shaped XLD contour. 
  public void gen_arrow_contour_xld (out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
      HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TempArrow=null;

    // Local control variables 

    HTuple hv_Length = null, hv_ZeroLengthIndices = null;
    HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
    HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
    HTuple hv_ColP2 = null, hv_Index = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    HOperatorSet.GenEmptyObj(out ho_TempArrow);
    //This procedure generates arrow shaped XLD contours,
    //pointing from (Row1, Column1) to (Row2, Column2).
    //If starting and end point are identical, a contour consisting
    //of a single point is returned.
    //
    //input parameteres:
    //Row1, Column1: Coordinates of the arrows' starting points
    //Row2, Column2: Coordinates of the arrows' end points
    //HeadLength, HeadWidth: Size of the arrow heads in pixels
    //
    //output parameter:
    //Arrow: The resulting XLD contour
    //
    //The input tuples Row1, Column1, Row2, and Column2 have to be of
    //the same length.
    //HeadLength and HeadWidth either have to be of the same length as
    //Row1, Column1, Row2, and Column2 or have to be a single element.
    //If one of the above restrictions is violated, an error will occur.
    //
    //
    //Init
    ho_Arrow.Dispose();
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    //
    //Calculate the arrow length
    HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
    //
    //Mark arrows with identical start and end point
    //(set Length to -1 to avoid division-by-zero exception)
    hv_ZeroLengthIndices = hv_Length.TupleFind(0);
    if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
    {
      if (hv_Length == null)
        hv_Length = new HTuple();
      hv_Length[hv_ZeroLengthIndices] = -1;
    }
    //
    //Calculate auxiliary variables.
    hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
    hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
    hv_HalfHeadWidth = hv_HeadWidth/2.0;
    //
    //Calculate end points of the arrow head.
    hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
    hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
    hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
    hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
    //
    //Finally create output XLD contour for each input point pair
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
      {
        //Create_ single points for arrows with identical start and end point
        ho_TempArrow.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(hv_Index), 
            hv_Column1.TupleSelect(hv_Index));
      }
      else
      {
        //Create arrow contour
        ho_TempArrow.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
            hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
            hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
            hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)), 
            ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
            hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
            hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
            hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
      ho_Arrow.Dispose();
      ho_Arrow = ExpTmpOutVar_0;
      }
    }
    ho_TempArrow.Dispose();

    return;
  }

  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_Image11117455Cam0, ho_Regions;
    HObject ho_Regions1;

    // Local control variables 

    HTuple hv_WindowHandle = new HTuple(), hv_ROIRows = null;
    HTuple hv_ROICols = null, hv_Direct = null, hv_ResultRow = null;
    HTuple hv_ResultColumn = null, hv_ArcType = null, hv_Index = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Image11117455Cam0);
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_Regions1);
    ho_Image.Dispose();
    HOperatorSet.ReadImage(out ho_Image, "C:/Users/cn11321/source/Code/image/RawImage/Robot_03.png");
    ho_Image11117455Cam0.Dispose();
    HOperatorSet.MeanImage(ho_Image, out ho_Image11117455Cam0, 3, 3);
    //dev_close_window(...);
    dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowHandle);
    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
    HDevelopStop();
    ho_Regions.Dispose();
    draw_spoke(ho_Image, out ho_Regions, hv_ExpDefaultWinHandle, 30, 15, 5, out hv_ROIRows, 
        out hv_ROICols, out hv_Direct);
    ho_Regions1.Dispose();
    spoke(ho_Image, out ho_Regions1, 30, 15, 5, 1, 20, "all", "max", hv_ROIRows, 
        hv_ROICols, hv_Direct, out hv_ResultRow, out hv_ResultColumn, out hv_ArcType);
    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "yellow");
    HOperatorSet.ClearWindow(hv_ExpDefaultWinHandle);
    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ResultRow.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      HOperatorSet.DispCross(hv_ExpDefaultWinHandle, hv_ResultRow.TupleSelect(hv_Index), 
          hv_ResultColumn.TupleSelect(hv_Index), 6, 0);
    }

    //gen_contour_polygon_xld (Contour, ResultRow, ResultColumn)

    //* fit_circle_contour_xld (Contour, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)
    //dev_set_draw ('margin')
    //dev_clear_window ()
    //dev_display (Image)
    //* gen_circle (Circle, Row, Column, Radius)

    //* dev_display (Circle)


    ho_Image.Dispose();
    ho_Image11117455Cam0.Dispose();
    ho_Regions.Dispose();
    ho_Regions1.Dispose();

  }

  public void InitHalcon()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
  }

  public void RunHalcon(HTuple Window)
  {
    hv_ExpDefaultWinHandle = Window;
    action();
  }

}

