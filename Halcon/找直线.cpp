///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 17.12
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);

// Procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image11117455Cam0, ho_Rectangle, ho_Contour;
  HObject  ho_RegionLines;

  // Local control variables
  HTuple  hv_PreFile, hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2;
  HTuple  hv_RoiTuple, hv_CaliperNum, hv_NewL1, hv_NewL2;
  HTuple  hv_Sin, hv_Cos, hv_BaseRow, hv_BaseCol, hv_newRow;
  HTuple  hv_newCol, hv_RowFirstList, hv_ColFirstList, hv_Index;
  HTuple  hv_MeasureHandle, hv_RowEdge, hv_ColumnEdge, hv_Amplitude;
  HTuple  hv_Distance, hv_RowBegin, hv_ColBegin, hv_RowEnd;
  HTuple  hv_ColEnd, hv_Nr, hv_Nc, hv_Dist;

  ReadImage(&ho_Image11117455Cam0, "C:/Users/cn11321/source/Code/image/RawImage/Robot_08.png");
  hv_PreFile = "./Para/L6/";
  MeanImage(ho_Image11117455Cam0, &ho_Image11117455Cam0, 3, 3);
  GetImageSize(ho_Image11117455Cam0, &hv_Width, &hv_Height);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  dev_open_window_fit_image(ho_Image11117455Cam0, 0, 0, -1, -1, &hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image11117455Cam0, HDevWindowStack::GetActive());
  //stop ()
  //draw_rectangle2 (WindowHandle, Row, Column, Phi, Length1, Length2)
  //RoiTuple := [Row, Column, Phi, Length1, Length2,1,20,'negative','first']
  //write_tuple (RoiTuple, PreFile+'Roi.tup')
  ReadTuple(hv_PreFile+"Roi.tup", &hv_RoiTuple);


  hv_Row = ((const HTuple&)hv_RoiTuple)[0];
  hv_Column = ((const HTuple&)hv_RoiTuple)[1];
  hv_Phi = ((const HTuple&)hv_RoiTuple)[2];
  hv_Length1 = ((const HTuple&)hv_RoiTuple)[3];
  hv_Length2 = ((const HTuple&)hv_RoiTuple)[4];
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");

  GenRectangle2(&ho_Rectangle, hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2);
  //dilation_circle (Rectangle, RegionDilation, 5)
  //reduce_domain (Image11117455Cam0, RegionDilation, ImageReduced)
  //scale_image_max (ImageReduced, ImageReduced)


  hv_CaliperNum = 100;

  hv_NewL1 = hv_Length1;
  hv_NewL2 = hv_Length2/(hv_CaliperNum-1);

  TupleSin(hv_Phi, &hv_Sin);
  TupleCos(hv_Phi, &hv_Cos);

  hv_BaseRow = hv_Row+(hv_Length2*hv_Cos);
  hv_BaseCol = hv_Column+(hv_Length2*hv_Sin);

  hv_newRow = hv_BaseRow;
  hv_newCol = hv_BaseCol;

  hv_RowFirstList = HTuple();
  hv_ColFirstList = HTuple();


  {
  HTuple end_val45 = hv_CaliperNum;
  HTuple step_val45 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
  {
    GenMeasureRectangle2(hv_newRow, hv_newCol, hv_Phi, hv_NewL1, hv_NewL2, hv_Width, 
        hv_Height, "nearest_neighbor", &hv_MeasureHandle);
    //positive  黑-》白 negative  白-》黑

    MeasurePos(ho_Image11117455Cam0, hv_MeasureHandle, HTuple(hv_RoiTuple[5]), HTuple(hv_RoiTuple[6]), 
        HTuple(hv_RoiTuple[7]), HTuple(hv_RoiTuple[8]), &hv_RowEdge, &hv_ColumnEdge, 
        &hv_Amplitude, &hv_Distance);

    hv_newRow = hv_BaseRow-(((hv_NewL2*hv_Cos)*hv_Index)*2);
    hv_newCol = hv_BaseCol-(((hv_NewL2*hv_Sin)*hv_Index)*2);

    if (0 != ((hv_RowEdge.TupleLength())>0))
    {
      hv_RowFirstList = hv_RowFirstList.TupleConcat(hv_RowEdge);
      hv_ColFirstList = hv_ColFirstList.TupleConcat(hv_ColumnEdge);
    }
    CloseMeasure(hv_MeasureHandle);
  }
  }



  if (0 != ((hv_RowFirstList.TupleLength())>2))
  {
    GenContourPolygonXld(&ho_Contour, hv_RowFirstList, hv_ColFirstList);
    FitLineContourXld(ho_Contour, "gauss", -1, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
        &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);

  }
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //dev_set_part (807, 961, 954, 2306)
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image11117455Cam0, HDevWindowStack::GetActive());

  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"yellow");
  //for Index1 := 0 to |RowFirstList|-1 by 1
    //disp_cross (WindowHandle, RowFirstList[Index1], ColFirstList[Index1], 6, Phi)
  //endfor


  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"red");

  GenRegionLine(&ho_RegionLines, hv_RowBegin, hv_ColBegin, hv_RowEnd, hv_ColEnd);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionLines, HDevWindowStack::GetActive());




}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
    XInitThreads();
#endif

    // Default settings used in HDevelop (can be omitted) 
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


