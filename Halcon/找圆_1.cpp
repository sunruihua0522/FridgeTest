///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 17.12
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
void draw_spoke (HObject ho_Image, HObject *ho_Regions, HTuple hv_WindowHandle, HTuple hv_Elements, 
    HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple *hv_ROIRows, HTuple *hv_ROICols, 
    HTuple *hv_Direct);
void spoke (HObject ho_Image, HObject *ho_Regions, HTuple hv_Elements, HTuple hv_DetectHeight, 
    HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold, HTuple hv_Transition, 
    HTuple hv_Select, HTuple hv_ROIRows, HTuple hv_ROICols, HTuple hv_Direct, HTuple *hv_ResultRow, 
    HTuple *hv_ResultColumn, HTuple *hv_ArcType);
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);

// Procedures 
// External procedures 
void draw_spoke (HObject ho_Image, HObject *ho_Regions, HTuple hv_WindowHandle, HTuple hv_Elements, 
    HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple *hv_ROIRows, HTuple *hv_ROICols, 
    HTuple *hv_Direct)
{

  // Local iconic variables
  HObject  ho_ContOut1, ho_Contour, ho_ContCircle;
  HObject  ho_Cross, ho_Rectangle1, ho_Arrow1;

  // Local control variables
  HTuple  hv_Rows, hv_Cols, hv_Weights, hv_Length1;
  HTuple  hv_RowC, hv_ColumnC, hv_Radius, hv_StartPhi, hv_EndPhi;
  HTuple  hv_PointOrder, hv_RowXLD, hv_ColXLD, hv_Row1, hv_Column1;
  HTuple  hv_Row2, hv_Column2, hv_DistanceStart, hv_DistanceEnd;
  HTuple  hv_Length2, hv_i, hv_j, hv_RowE, hv_ColE, hv_ATan;
  HTuple  hv_RowL2, hv_RowL1, hv_ColL2, hv_ColL1;

  //提示
  disp_message(hv_WindowHandle, HTuple("1、画4个以上点确定一个圆弧,点击右键确认"), 
      "window", 12, 12, "red", "false");
  //产生一个空显示对象，用于显示
  GenEmptyObj(&(*ho_Regions));
  //沿着圆弧或圆的边缘画点
  DrawNurbs(&ho_ContOut1, hv_WindowHandle, "true", "true", "true", "true", 3, &hv_Rows, 
      &hv_Cols, &hv_Weights);
  //至少要4个点
  TupleLength(hv_Weights, &hv_Length1);
  if (0 != (hv_Length1<4))
  {
    disp_message(hv_WindowHandle, "提示：点数太少，请重画", "window", 
        32, 12, "red", "false");
    (*hv_ROIRows) = HTuple();
    (*hv_ROICols) = HTuple();
    return;
  }
  //获取点
  (*hv_ROIRows) = hv_Rows;
  (*hv_ROICols) = hv_Cols;
  //产生xld
  GenContourPolygonXld(&ho_Contour, (*hv_ROIRows), (*hv_ROICols));
  //用回归线法（不抛出异常点，所有点权重一样）拟合圆
  FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, &hv_RowC, &hv_ColumnC, 
      &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  //根据拟合结果产生xld，并保持到显示对象
  GenCircleContourXld(&ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius, hv_StartPhi, 
      hv_EndPhi, hv_PointOrder, 3);
  ConcatObj((*ho_Regions), ho_ContCircle, &(*ho_Regions));

  //获取圆或圆弧xld上的点坐标
  GetContourXld(ho_ContCircle, &hv_RowXLD, &hv_ColXLD);
  //显示图像和圆弧
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ContCircle, HDevWindowStack::GetActive());
  //产生并显示圆心
  GenCrossContourXld(&ho_Cross, hv_RowC, hv_ColumnC, 60, 0.785398);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Cross, HDevWindowStack::GetActive());
  //提示
  disp_message(hv_WindowHandle, "2、远离圆心，画箭头确定边缘检测方向，点击右键确认", 
      "window", 12, 12, "red", "false");
  //画线，确定检测方向
  DrawLine(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  //求圆心到检测方向直线起点的距离
  DistancePp(hv_RowC, hv_ColumnC, hv_Row1, hv_Column1, &hv_DistanceStart);
  //求圆心到检测方向直线终点的距离
  DistancePp(hv_RowC, hv_ColumnC, hv_Row2, hv_Column2, &hv_DistanceEnd);

  //求圆或圆弧xld上的点的数量
  TupleLength(hv_ColXLD, &hv_Length2);
  //判断检测的边缘数量是否过少
  if (0 != (hv_Elements<3))
  {
    (*hv_ROIRows) = HTuple();
    (*hv_ROICols) = HTuple();
    disp_message(hv_WindowHandle, "检测的边缘数量太少，请重新设置!", 
        "window", 52, 12, "red", "false");
    return;
  }
  //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
  //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
  {
  HTuple end_val53 = hv_Elements-1;
  HTuple step_val53 = 1;
  for (hv_i=0; hv_i.Continue(end_val53, step_val53); hv_i += step_val53)
  {

    if (0 != (HTuple(hv_RowXLD[0])==HTuple(hv_RowXLD[hv_Length2-1])))
    {
      //xld的起点和终点坐标相对，为圆
      TupleInt(((1.0*hv_Length2)/hv_Elements)*hv_i, &hv_j);

    }
    else
    {
      //否则为圆弧
      TupleInt(((1.0*hv_Length2)/(hv_Elements-1))*hv_i, &hv_j);
    }
    //索引越界，强制赋值为最后一个索引
    if (0 != (hv_j>=hv_Length2))
    {
      hv_j = hv_Length2-1;
      //continue
    }
    //获取卡尺工具中心
    hv_RowE = HTuple(hv_RowXLD[hv_j]);
    hv_ColE = HTuple(hv_ColXLD[hv_j]);

    //如果圆心到检测方向直线的起点的距离大于圆心到检测方向直线的终点的距离，搜索方向由圆外指向圆心
    //如果圆心到检测方向直线的起点的距离不大于圆心到检测方向直线的终点的距离，搜索方向由圆心指向圆外
    if (0 != (hv_DistanceStart>hv_DistanceEnd))
    {
      //求卡尺工具的边缘搜索方向
      //求圆心指向边缘的矢量的角度
      TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, &hv_ATan);
      //角度反向
      hv_ATan = (HTuple(180).TupleRad())+hv_ATan;
      //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
      (*hv_Direct) = "inner";
    }
    else
    {
      //求卡尺工具的边缘搜索方向
      //求圆心指向边缘的矢量的角度
      TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, &hv_ATan);
      //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
      (*hv_Direct) = "outer";
    }

    //产生卡尺xld，并保持到显示对象
    GenRectangle2ContourXld(&ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan, hv_DetectHeight/2, 
        hv_DetectWidth/2);
    ConcatObj((*ho_Regions), ho_Rectangle1, &(*ho_Regions));

    //用箭头xld指示边缘搜索方向，并保持到显示对象
    if (0 != (hv_i==0))
    {
      hv_RowL2 = hv_RowE+((hv_DetectHeight/2)*((-hv_ATan).TupleSin()));
      hv_RowL1 = hv_RowE-((hv_DetectHeight/2)*((-hv_ATan).TupleSin()));
      hv_ColL2 = hv_ColE+((hv_DetectHeight/2)*((-hv_ATan).TupleCos()));
      hv_ColL1 = hv_ColE-((hv_DetectHeight/2)*((-hv_ATan).TupleCos()));
      gen_arrow_contour_xld(&ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2, 25, 
          25);
      ConcatObj((*ho_Regions), ho_Arrow1, &(*ho_Regions));
    }
  }
  }

  return;
}

void spoke (HObject ho_Image, HObject *ho_Regions, HTuple hv_Elements, HTuple hv_DetectHeight, 
    HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold, HTuple hv_Transition, 
    HTuple hv_Select, HTuple hv_ROIRows, HTuple hv_ROICols, HTuple hv_Direct, HTuple *hv_ResultRow, 
    HTuple *hv_ResultColumn, HTuple *hv_ArcType)
{

  // Local iconic variables
  HObject  ho_Contour, ho_ContCircle, ho_Rectangle1;
  HObject  ho_Arrow1;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_RowC, hv_ColumnC;
  HTuple  hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder;
  HTuple  hv_RowXLD, hv_ColXLD, hv_Length2, hv_i, hv_j, hv_RowE;
  HTuple  hv_ColE, hv_ATan, hv_RowL2, hv_RowL1, hv_ColL2;
  HTuple  hv_ColL1, hv_MsrHandle_Measure, hv_RowEdge, hv_ColEdge;
  HTuple  hv_Amplitude, hv_Distance, hv_tRow, hv_tCol, hv_t;
  HTuple  hv_Number, hv_k;

  //获取图像尺寸
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //产生一个空显示对象，用于显示
  GenEmptyObj(&(*ho_Regions));
  //初始化边缘坐标数组
  (*hv_ResultRow) = HTuple();
  (*hv_ResultColumn) = HTuple();

  //产生xld
  GenContourPolygonXld(&ho_Contour, hv_ROIRows, hv_ROICols);
  //用回归线法（不抛出异常点，所有点权重一样）拟合圆
  FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, &hv_RowC, &hv_ColumnC, 
      &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  //根据拟合结果产生xld，并保持到显示对象
  GenCircleContourXld(&ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius, hv_StartPhi, 
      hv_EndPhi, hv_PointOrder, 3);
  ConcatObj((*ho_Regions), ho_ContCircle, &(*ho_Regions));

  //获取圆或圆弧xld上的点坐标
  GetContourXld(ho_ContCircle, &hv_RowXLD, &hv_ColXLD);

  //求圆或圆弧xld上的点的数量
  TupleLength(hv_ColXLD, &hv_Length2);
  if (0 != (hv_Elements<3))
  {
    //    disp_message (WindowHandle, '检测的边缘数量太少，请重新设置!', 'window', 52, 12, 'red', 'false')
    return;
  }
  //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
  //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
  {
  HTuple end_val27 = hv_Elements-1;
  HTuple step_val27 = 1;
  for (hv_i=0; hv_i.Continue(end_val27, step_val27); hv_i += step_val27)
  {

    if (0 != (HTuple(hv_RowXLD[0])==HTuple(hv_RowXLD[hv_Length2-1])))
    {
      //xld的起点和终点坐标相对，为圆
      TupleInt(((1.0*hv_Length2)/hv_Elements)*hv_i, &hv_j);
      (*hv_ArcType) = "circle";
    }
    else
    {
      //否则为圆弧
      TupleInt(((1.0*hv_Length2)/(hv_Elements-1))*hv_i, &hv_j);
      (*hv_ArcType) = "arc";
    }
    //索引越界，强制赋值为最后一个索引
    if (0 != (hv_j>=hv_Length2))
    {
      hv_j = hv_Length2-1;
      //continue
    }
    //获取卡尺工具中心
    hv_RowE = HTuple(hv_RowXLD[hv_j]);
    hv_ColE = HTuple(hv_ColXLD[hv_j]);

    //超出图像区域，不检测，否则容易报异常
    if (0 != (HTuple(HTuple(HTuple(hv_RowE>(hv_Height-1)).TupleOr(hv_RowE<0)).TupleOr(hv_ColE>(hv_Width-1))).TupleOr(hv_ColE<0)))
    {
      continue;
    }
    //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
    if (0 != (hv_Direct==HTuple("inner")))
    {
      //求卡尺工具的边缘搜索方向
      //求圆心指向边缘的矢量的角度
      TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, &hv_ATan);
      //角度反向
      hv_ATan = (HTuple(180).TupleRad())+hv_ATan;
    }
    else
    {
      //求卡尺工具的边缘搜索方向
      //求圆心指向边缘的矢量的角度
      TupleAtan2((-hv_RowE)+hv_RowC, hv_ColE-hv_ColumnC, &hv_ATan);
    }


    //产生卡尺xld，并保持到显示对象
    GenRectangle2ContourXld(&ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan, hv_DetectHeight/2, 
        hv_DetectWidth/2);
    ConcatObj((*ho_Regions), ho_Rectangle1, &(*ho_Regions));
    //用箭头xld指示边缘搜索方向，并保持到显示对象
    if (0 != (hv_i==0))
    {
      hv_RowL2 = hv_RowE+((hv_DetectHeight/2)*((-hv_ATan).TupleSin()));
      hv_RowL1 = hv_RowE-((hv_DetectHeight/2)*((-hv_ATan).TupleSin()));
      hv_ColL2 = hv_ColE+((hv_DetectHeight/2)*((-hv_ATan).TupleCos()));
      hv_ColL1 = hv_ColE-((hv_DetectHeight/2)*((-hv_ATan).TupleCos()));
      gen_arrow_contour_xld(&ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2, 25, 
          25);
      ConcatObj((*ho_Regions), ho_Arrow1, &(*ho_Regions));
    }


    //产生测量对象句柄
    GenMeasureRectangle2(hv_RowE, hv_ColE, hv_ATan, hv_DetectHeight/2, hv_DetectWidth/2, 
        hv_Width, hv_Height, "nearest_neighbor", &hv_MsrHandle_Measure);

    //设置极性
    if (0 != (hv_Transition==HTuple("negative")))
    {
      hv_Transition = "negative";
    }
    else
    {
      if (0 != (hv_Transition==HTuple("positive")))
      {

        hv_Transition = "positive";
      }
      else
      {
        hv_Transition = "all";
      }
    }
    //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
    if (0 != (hv_Select==HTuple("first")))
    {
      hv_Select = "first";
    }
    else
    {
      if (0 != (hv_Select==HTuple("last")))
      {

        hv_Select = "last";
      }
      else
      {
        hv_Select = "all";
      }
    }
    //检测边缘
    MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold, hv_Transition, 
        hv_Select, &hv_RowEdge, &hv_ColEdge, &hv_Amplitude, &hv_Distance);
    //清除测量对象句柄
    CloseMeasure(hv_MsrHandle_Measure);
    //临时变量初始化
    //tRow，tCol保存找到指定边缘的坐标
    hv_tRow = 0;
    hv_tCol = 0;
    //t保存边缘的幅度绝对值
    hv_t = 0;
    TupleLength(hv_RowEdge, &hv_Number);
    //找到的边缘必须至少为1个
    if (0 != (hv_Number<1))
    {
      continue;
    }
    //有多个边缘时，选择幅度绝对值最大的边缘
    {
    HTuple end_val120 = hv_Number-1;
    HTuple step_val120 = 1;
    for (hv_k=0; hv_k.Continue(end_val120, step_val120); hv_k += step_val120)
    {
      if (0 != ((HTuple(hv_Amplitude[hv_k]).TupleAbs())>hv_t))
      {

        hv_tRow = HTuple(hv_RowEdge[hv_k]);
        hv_tCol = HTuple(hv_ColEdge[hv_k]);
        hv_t = HTuple(hv_Amplitude[hv_k]).TupleAbs();
      }
    }
    }
    //把找到的边缘保存在输出数组
    if (0 != (hv_t>0))
    {

      (*hv_ResultRow) = (*hv_ResultRow).TupleConcat(hv_tRow);
      (*hv_ResultColumn) = (*hv_ResultColumn).TupleConcat(hv_tCol);
    }
  }
  }


  return;
}

// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
{

  // Local iconic variables
  HObject  ho_TempArrow;

  // Local control variables
  HTuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
  HTuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
  HTuple  hv_ColP2, hv_Index;

  //This procedure generates arrow shaped XLD contours,
  //pointing from (Row1, Column1) to (Row2, Column2).
  //If starting and end point are identical, a contour consisting
  //of a single point is returned.
  //
  //input parameteres:
  //Row1, Column1: Coordinates of the arrows' starting points
  //Row2, Column2: Coordinates of the arrows' end points
  //HeadLength, HeadWidth: Size of the arrow heads in pixels
  //
  //output parameter:
  //Arrow: The resulting XLD contour
  //
  //The input tuples Row1, Column1, Row2, and Column2 have to be of
  //the same length.
  //HeadLength and HeadWidth either have to be of the same length as
  //Row1, Column1, Row2, and Column2 or have to be a single element.
  //If one of the above restrictions is violated, an error will occur.
  //
  //
  //Init
  GenEmptyObj(&(*ho_Arrow));
  //
  //Calculate the arrow length
  DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);
  //
  //Mark arrows with identical start and end point
  //(set Length to -1 to avoid division-by-zero exception)
  hv_ZeroLengthIndices = hv_Length.TupleFind(0);
  if (0 != (hv_ZeroLengthIndices!=-1))
  {
    hv_Length[hv_ZeroLengthIndices] = -1;
  }
  //
  //Calculate auxiliary variables.
  hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
  hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
  hv_HalfHeadWidth = hv_HeadWidth/2.0;
  //
  //Calculate end points of the arrow head.
  hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
  hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
  hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
  hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
  //
  //Finally create output XLD contour for each input point pair
  {
  HTuple end_val45 = (hv_Length.TupleLength())-1;
  HTuple step_val45 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
  {
    if (0 != (HTuple(hv_Length[hv_Index])==-1))
    {
      //Create_ single points for arrows with identical start and end point
      GenContourPolygonXld(&ho_TempArrow, HTuple(hv_Row1[hv_Index]), HTuple(hv_Column1[hv_Index]));
    }
    else
    {
      //Create arrow contour
      GenContourPolygonXld(&ho_TempArrow, ((((HTuple(hv_Row1[hv_Index]).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP1[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP2[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index])), 
          ((((HTuple(hv_Column1[hv_Index]).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP1[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP2[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index])));
    }
    ConcatObj((*ho_Arrow), ho_TempArrow, &(*ho_Arrow));
  }
  }
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GenParamName, hv_GenParamValue;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Column: The column coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically...
  //   - if |Row| == |Column| == 1: for each new textline
  //   = else for each text position.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow
  //       otherwise -> use given string as color string for the shadow color
  //
  //It is possible to display multiple text strings in a single call.
  //In this case, some restrictions apply:
  //- Multiple text positions can be defined by specifying a tuple
  //  with multiple Row and/or Column coordinates, i.e.:
  //  - |Row| == n, |Column| == n
  //  - |Row| == n, |Column| == 1
  //  - |Row| == 1, |Column| == n
  //- If |Row| == |Column| == 1,
  //  each element of String is display in a new textline.
  //- If multiple positions or specified, the number of Strings
  //  must match the number of positions, i.e.:
  //  - Either |String| == n (each string is displayed at the
  //                          corresponding position),
  //  - or     |String| == 1 (The string is displayed n times).
  //
  //
  //Convert the parameters for disp_text.
  if (0 != (HTuple(hv_Row==HTuple()).TupleOr(hv_Column==HTuple())))
  {
    return;
  }
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  //
  //Convert the parameter Box to generic parameters.
  hv_GenParamName = HTuple();
  hv_GenParamValue = HTuple();
  if (0 != ((hv_Box.TupleLength())>0))
  {
    if (0 != (HTuple(hv_Box[0])==HTuple("false")))
    {
      //Display no box
      hv_GenParamName = hv_GenParamName.TupleConcat("box");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[0])!=HTuple("true")))
    {
      //Set a color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
    }
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      //Display no shadow.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[1])!=HTuple("true")))
    {
      //Set a shadow color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
    }
  }
  //Restore default CoordSystem behavior.
  if (0 != (hv_CoordSystem!=HTuple("window")))
  {
    hv_CoordSystem = "image";
  }
  //
  if (0 != (hv_Color==HTuple("")))
  {
    //disp_text does not accept an empty string for Color.
    hv_Color = HTuple();
  }
  //
  DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color, 
      hv_GenParamName, hv_GenParamValue);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Rectangle, ho_Regions, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_Regions1, ho_Contour, ho_Circle;

  // Local control variables
  HTuple  hv_Index1, hv_Group, hv_PoseIndex, hv_CircleIndex;
  HTuple  hv_PreFile, hv_ModelID, hv_RowModel, hv_ColumnModel;
  HTuple  hv_AngleModel, hv_Score, hv_RowOrigin, hv_ColumnOrigin;
  HTuple  hv_HomMat2D, hv_WindowHandle, hv_spoke_paras, hv_Row1;
  HTuple  hv_Column1, hv_RectRoiSearch, hv_AbsoluteHisto;
  HTuple  hv_RelativeHisto, hv_Indices, hv_IndexSelect, hv_SelectIndex;
  HTuple  hv_Area, hv_Row2, hv_Column2, hv_Row3, hv_Column3;
  HTuple  hv_ROIRows, hv_ROICols, hv_Direct, hv_ResultRow;
  HTuple  hv_ResultColumn, hv_ArcType, hv_Index, hv_Row, hv_Column;
  HTuple  hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder;

  for (hv_Index1=1; hv_Index1<=9; hv_Index1+=1)
  {

    hv_Group = hv_Index1;
    hv_PoseIndex = 8;
    hv_CircleIndex = 1;
    ReadImage(&ho_Image, ((("C:/Users/cn11321/source/repos/TestDemo/Halcon/image/RawImage/"+hv_Group)+"/Robot_0")+hv_PoseIndex)+".png");


    //做变换
    hv_PreFile = ("./Para/Pose"+hv_PoseIndex)+"/Model/";
    ReadShapeModel(hv_PreFile+"Model.shm", &hv_ModelID);
    FindShapeModel(ho_Image, hv_ModelID, -0.39, 0.79, 0.2, 1, 0.5, "least_squares", 
        0, 0.9, &hv_RowModel, &hv_ColumnModel, &hv_AngleModel, &hv_Score);
    GetShapeModelOrigin(hv_ModelID, &hv_RowOrigin, &hv_ColumnOrigin);
    VectorAngleToRigid(hv_RowModel-hv_RowOrigin, hv_ColumnModel-hv_ColumnOrigin, 
        hv_AngleModel, hv_RowOrigin, hv_ColumnOrigin, 0, &hv_HomMat2D);
    AffineTransImage(ho_Image, &ho_Image, hv_HomMat2D, "constant", "false");


    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());
    dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, &hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image, HDevWindowStack::GetActive());
    //stop ()
    hv_PreFile = ((("./Para/Pose"+hv_PoseIndex)+"/C")+hv_CircleIndex)+"/";
    hv_spoke_paras.Clear();
    hv_spoke_paras[0] = 30;
    hv_spoke_paras[1] = 15;
    hv_spoke_paras[2] = 5;
    hv_spoke_paras[3] = 1;
    hv_spoke_paras[4] = 5;
    hv_spoke_paras[5] = "negative";
    hv_spoke_paras[6] = "first";

    //stop ()

    //画矩形Reduce区域
    //draw_rectangle2 (WindowHandle, Row1, Column1, Phi, Length1, Length2)
    //*     RectRoiSearch := [Row1, Column1, Phi, Length1, Length2]
    //write_tuple (RectRoiSearch, './Para/Pose'+PoseIndex+'/C'+CircleIndex+'/RectRoiSearch.tup')


    ReadTuple(((("./Para/Pose"+hv_PoseIndex)+"/C")+hv_CircleIndex)+"/RectRoiSearch.tup", 
        &hv_RectRoiSearch);
    GenRectangle2(&ho_Rectangle, HTuple(hv_RectRoiSearch[0]), HTuple(hv_RectRoiSearch[1]), 
        HTuple(hv_RectRoiSearch[2]), HTuple(hv_RectRoiSearch[3]), HTuple(hv_RectRoiSearch[4]));
    ReduceDomain(ho_Image, ho_Rectangle, &ho_Image);
    ScaleImageMax(ho_Image, &ho_Image);


    //找圆形区域
    GrayHisto(ho_Rectangle, ho_Image, &hv_AbsoluteHisto, &hv_RelativeHisto);
    TupleSortIndex(hv_AbsoluteHisto, &hv_Indices);

    hv_IndexSelect = 255;
    while (0 != ((HTuple(hv_Indices[hv_IndexSelect])+20)>255))
    {
      hv_IndexSelect = hv_IndexSelect-1;
    }
    Threshold(ho_Image, &ho_Regions, HTuple(hv_Indices[hv_IndexSelect])+30, 255);
    Connection(ho_Regions, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("area").Append("circularity")), 
        "and", (HTuple(266.06).Append(0.5)), (HTuple(5532.11).Append(1)));
    SortRegion(ho_SelectedRegions, &ho_SelectedRegions, "first_point", "true", "column");

    if (0 != (hv_CircleIndex==1))
    {
      hv_SelectIndex = 0;
    }
    else
    {
      hv_SelectIndex = 1;
    }

    AreaCenter(ho_SelectedRegions, &hv_Area, &hv_Row1, &hv_Column1);
    IntersectionLineCircle(HTuple(hv_Row1[hv_SelectIndex])-50, HTuple(hv_Column1[hv_SelectIndex]), 
        HTuple(hv_Row1[hv_SelectIndex])+50, HTuple(hv_Column1[hv_SelectIndex]), HTuple(hv_Row1[hv_SelectIndex]), 
        HTuple(hv_Column1[hv_SelectIndex]), 26, 0, 6.28318, "positive", &hv_Row2, 
        &hv_Column2);
    IntersectionLineCircle(HTuple(hv_Row1[hv_SelectIndex]), HTuple(hv_Column1[hv_SelectIndex])-50, 
        HTuple(hv_Row1[hv_SelectIndex]), HTuple(hv_Column1[hv_SelectIndex])+50, HTuple(hv_Row1[hv_SelectIndex]), 
        HTuple(hv_Column1[hv_SelectIndex]), 26, 0, 6.28318, "positive", &hv_Row3, 
        &hv_Column3);
    hv_ROIRows.Clear();
    hv_ROIRows.Append(hv_Row2);
    hv_ROIRows.Append(hv_Row3);
    hv_ROIRows.Append(HTuple(hv_Row2[0]));
    hv_ROICols.Clear();
    hv_ROICols.Append(hv_Column2);
    hv_ROICols.Append(hv_Column3);
    hv_ROICols.Append(HTuple(hv_Column2[0]));
    hv_Direct = "inner";

    //画圆形搜索区域
    //draw_spoke (Image, Regions, WindowHandle, 100, 15, 5, ROIRows, ROICols, Direct)
    //write_tuple (spoke_paras, PreFile+'spokeParas.tup')
    //write_tuple (ROIRows, PreFile+'sopkeParaRow.tup')
    //write_tuple (ROICols, PreFile+'sopkeParaCol.tup')
    //write_tuple (Direct, PreFile+'sopkeParaDir.tup')


    ReadTuple(hv_PreFile+"spokeParas.tup", &hv_spoke_paras);
    //read_tuple (PreFile+'sopkeParaRow.tup', ROIRows)
    //read_tuple (PreFile+'sopkeParaCol.tup', ROICols)
    //read_tuple (PreFile+'sopkeParaDir.tup', Direct)


    spoke(ho_Image, &ho_Regions1, HTuple(hv_spoke_paras[0]), HTuple(hv_spoke_paras[1]), 
        HTuple(hv_spoke_paras[2]), HTuple(hv_spoke_paras[3]), HTuple(hv_spoke_paras[4]), 
        HTuple(hv_spoke_paras[5]), HTuple(hv_spoke_paras[6]), hv_ROIRows, hv_ROICols, 
        hv_Direct, &hv_ResultRow, &hv_ResultColumn, &hv_ArcType);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"yellow");
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    //dev_set_part (867, 1050, 1086, 1502)
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image, HDevWindowStack::GetActive());
    {
    HTuple end_val83 = (hv_ResultRow.TupleLength())-1;
    HTuple step_val83 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val83, step_val83); hv_Index += step_val83)
    {
      DispCross(hv_WindowHandle, HTuple(hv_ResultRow[hv_Index]), HTuple(hv_ResultColumn[hv_Index]), 
          6, 0);
    }
    }
    GenContourPolygonXld(&ho_Contour, hv_ResultRow, hv_ResultColumn);
    FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 3, 2, &hv_Row, &hv_Column, 
        &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image, HDevWindowStack::GetActive());
    GenCircle(&ho_Circle, hv_Row, hv_Column, hv_Radius);

    if (HDevWindowStack::IsOpen())
      DispObj(ho_Circle, HDevWindowStack::GetActive());
    // stop(...); only in hdevelop
  }
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
    XInitThreads();
#endif

    // Default settings used in HDevelop (can be omitted) 
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


